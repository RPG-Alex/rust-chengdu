## Shown Concepts and location with explanation:
    Variables and Data Types: Variables are declared and used throughout your program. For example, let mut rng = rand::thread_rng(); declares a mutable variable rng of the type determined by the return value of rand::thread_rng(). In let mut lives: i8 = 1;, lives is a variable of type i8.

    Control Flow: The loop in the main function and the match statements inside the get_user_choice() function and main function are all examples of control flow. The if statements inside the match arms are also control flow structures.

    Error Handling: The .unwrap() method, seen in io::stdin().read_line(&mut choice).unwrap();, is a rudimentary form of error handling that essentially says "If this Result is an Err, panic and crash the program. Otherwise, give me the value." This isn't usually the best way to handle errors in a production program, but it is often used for simplicity in examples.

    Ownership and Borrowing: In choice.trim().to_lowercase().as_str(), the method .trim() borrows choice, returning a string slice (a borrowed reference to part of the original String), which is then transformed to lowercase, which requires taking ownership of the slice and producing a new String, which .as_str() then borrows to produce a &str again.

    Structs, Enums, and Pattern Matching: Your Choice enum is an example of an enum, and the match statements you use to determine what to do based on the Choice value are examples of pattern matching.

    Modules, Packages, and Crates: use std::io;, use std::io::Write;, and use rand::Rng; at the top of your file are examples of bringing modules and items from crates into scope. The rand in use rand::Rng; and let mut rng = rand::thread_rng(); is referring to the rand crate that must be listed in your Cargo.toml file. std::io and std::io::Write refer to the io module and Write trait in Rust's standard library, which is itself organized as a crate.

## cargo.lock explanation
    Cargo.lock is a file that Cargo, Rust's package manager, generates and uses to keep track of exact versions of all of your project's dependencies. This includes not only the top-level dependencies you specified in Cargo.toml, but their dependencies, and so on.

        Each entry in the Cargo.lock file includes the name of the crate, the version, the source of the crate, and the dependencies of the crate. It might look something like this:

        When you build your project for the first time, Cargo fetches all of your dependencies and records their exact versions in the Cargo.lock file. On subsequent builds, Cargo uses the versions locked in Cargo.lock instead of checking for newer versions. This helps to ensure that your project is reproducible: if you build your project again in the future, or if someone else builds your project, Cargo will use the same versions of dependencies.

        There's one more thing to mention about Cargo.lock. For binary (executable) projects, it's a good idea to check Cargo.lock into version control so that everyone who checks out your code gets the exact same dependencies. For library projects, it's more common to exclude Cargo.lock from version control, because people who depend on your library could have other versions of your dependencies in their projects, and you want to make sure your library works with a range of dependency versions.

        You generally won't need to edit the Cargo.lock file manually; Cargo will manage it for you. If you want to update the versions of your dependencies, you can use the cargo update command, and Cargo will update Cargo.lock automatically.


## generate Documentation
cargo doc --open
    /// - use this to delineate comments to show up in documentation
    source: https://doc.rust-lang.org/stable/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments